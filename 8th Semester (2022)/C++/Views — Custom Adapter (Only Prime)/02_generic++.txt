#include <fmt/ranges.h>
#include <ranges>
namespace rg = std::ranges;
namespace vs = rg::views;

struct only_prime : std::ranges::range_adaptor_closure<only_prime>
{
	static constexpr auto square_root(const std::integral auto n) noexcept
	{
		if (n <= 1) return n;

		std::remove_cvref_t<decltype(n)> left = 1, right = n;
		while (left <= right)
		{
			const auto mid = left + (right - left) / 2;
			if (mid == n / mid) return mid;
			if (mid < n / mid) left = mid + 1;
			else right = mid - 1;
		}
		return right;
	}

	static constexpr auto is_prime(const std::integral auto x) noexcept
	{
		for (auto i = square_root(x); i > 1; --i)
			if (x % i == 0) return false;
		return true;
	}

	template <std::ranges::range T>
	constexpr auto operator()(T&& r) const noexcept requires std::integral<rg::range_value_t<T>>
	{
		return r | std::views::filter(is_prime<rg::range_value_t<T>>);
	}
};

int main()
{
	auto my_range = rg::iota_view<size_t>(0) | only_prime{} | vs::take(25);
	fmt::print("{}", my_range);
}